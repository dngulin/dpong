// This file is auto-generated by the PlainBuffers compiler
// Generated at 2021-08-19T20:33:38.4428430+02:00

// ReSharper disable All

using System;
using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;

using FxNet.Math;
using FxNet.Random;

#pragma warning disable 649

namespace DPong.Level.State {
    [StructLayout(LayoutKind.Explicit)]
    public unsafe struct ScoresState {
        public const int SizeOf = 8;
        public const int AlignmentOf = 4;

        [FieldOffset(0)] private fixed byte _buffer[SizeOf];

        [FieldOffset(0)] public int Left;
        [FieldOffset(4)] public int Right;

        public void WriteDefault() {
            Left = 0;
            Right = 0;
        }

        public static bool operator ==(in ScoresState l, in ScoresState r) {
            fixed (byte* __l = l._buffer, __r = r._buffer) {
                return UnsafeUtility.MemCmp(__l, __r, SizeOf) == 0;
            }
        }
        public static bool operator !=(in ScoresState l, in ScoresState r) => !(l == r);

        public override bool Equals(object obj) => obj is ScoresState casted && this == casted;
        public override int GetHashCode() => throw new NotSupportedException();
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe struct BallState {
        public const int SizeOf = 40;
        public const int AlignmentOf = 8;

        [FieldOffset(0)] private fixed byte _buffer[SizeOf];

        [FieldOffset(0)] public FxNum FreezeCooldown;
        [FieldOffset(8)] public FxVec2 Speed;
        [FieldOffset(24)] public FxVec2 Position;

        public void WriteDefault() {
            FreezeCooldown = default;
            Speed = FxVec2.Zero;
            Position = FxVec2.Zero;
        }

        public static bool operator ==(in BallState l, in BallState r) {
            fixed (byte* __l = l._buffer, __r = r._buffer) {
                return UnsafeUtility.MemCmp(__l, __r, SizeOf) == 0;
            }
        }
        public static bool operator !=(in BallState l, in BallState r) => !(l == r);

        public override bool Equals(object obj) => obj is BallState casted && this == casted;
        public override int GetHashCode() => throw new NotSupportedException();
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe struct PaddleState {
        public const int SizeOf = 16;
        public const int AlignmentOf = 8;

        [FieldOffset(0)] private fixed byte _buffer[SizeOf];

        [FieldOffset(0)] public FxVec2 Position;

        public void WriteDefault() {
            Position = FxVec2.Zero;
        }

        public static bool operator ==(in PaddleState l, in PaddleState r) {
            fixed (byte* __l = l._buffer, __r = r._buffer) {
                return UnsafeUtility.MemCmp(__l, __r, SizeOf) == 0;
            }
        }
        public static bool operator !=(in PaddleState l, in PaddleState r) => !(l == r);

        public override bool Equals(object obj) => obj is PaddleState casted && this == casted;
        public override int GetHashCode() => throw new NotSupportedException();
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe struct PaddlesState {
        public const int SizeOf = 32;
        public const int AlignmentOf = 8;

        [FieldOffset(0)] private fixed byte _buffer[SizeOf];

        [FieldOffset(0)] public PaddleState Left;
        [FieldOffset(16)] public PaddleState Right;

        public void WriteDefault() {
            Left.WriteDefault();
            Right.WriteDefault();
        }

        public static bool operator ==(in PaddlesState l, in PaddlesState r) {
            fixed (byte* __l = l._buffer, __r = r._buffer) {
                return UnsafeUtility.MemCmp(__l, __r, SizeOf) == 0;
            }
        }
        public static bool operator !=(in PaddlesState l, in PaddlesState r) => !(l == r);

        public override bool Equals(object obj) => obj is PaddlesState casted && this == casted;
        public override int GetHashCode() => throw new NotSupportedException();
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe struct LevelState {
        public const int SizeOf = 120;
        public const int AlignmentOf = 8;

        [FieldOffset(0)] private fixed byte _buffer[SizeOf];

        [FieldOffset(0)] public FxNum Pace;
        [FieldOffset(8)] public FxRandomState Random;
        [FieldOffset(40)] public BallState Ball;
        [FieldOffset(80)] public PaddlesState Paddles;
        [FieldOffset(112)] public ScoresState Scores;

        public void WriteDefault() {
            Pace = default;
            Random = default;
            Ball.WriteDefault();
            Paddles.WriteDefault();
            Scores.WriteDefault();
        }

        public static bool operator ==(in LevelState l, in LevelState r) {
            fixed (byte* __l = l._buffer, __r = r._buffer) {
                return UnsafeUtility.MemCmp(__l, __r, SizeOf) == 0;
            }
        }
        public static bool operator !=(in LevelState l, in LevelState r) => !(l == r);

        public override bool Equals(object obj) => obj is LevelState casted && this == casted;
        public override int GetHashCode() => throw new NotSupportedException();
    }
}
